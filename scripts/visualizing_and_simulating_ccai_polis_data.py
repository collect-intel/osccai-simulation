# -*- coding: utf-8 -*-
"""Visualizing and Simulating CCAI Polis data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15LF1suaLzn37C1SqMPU-lt3X1YXKfIG1
"""

# Step 1: Set up Google Colab for file upload and necessary libraries
from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt

# Step 2: Upload the CSV file
uploaded = files.upload()

# Load the uploaded CSV into a DataFrame
filename = list(uploaded.keys())[0]
data = pd.read_csv(filename)

# Use CCAI Polis Data! Here: https://docs.google.com/spreadsheets/d/1KodCqXdizeG6JgeXoI2Vt2hozV1EGypIktnxpzh90dQ/edit?gid=1456672975#gid=1456672975

# Step 3: Calculate additional metrics
# Calculate pass votes per participant
data['n-pass'] = data['n-votes'] - (data['n-agree'] + data['n-disagree'])

# Calculate % agree, % disagree, and % pass per participant
data['% agree'] = data['n-agree'] / data['n-votes']
data['% disagree'] = data['n-disagree'] / data['n-votes']
data['% pass'] = data['n-pass'] / data['n-votes']

# Step 4: Plot distributions of various metrics

# Distribution of # of votes cast per Participant
plt.figure(figsize=(10, 6))
plt.hist(data['n-votes'], bins=20, color='skyblue', edgecolor='black')
plt.title('# of Votes Cast per Participant')
plt.xlabel('Number of Votes')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Distribution of % agree per Participant
plt.figure(figsize=(10, 6))
plt.hist(data['% agree'], bins=20, color='green', edgecolor='black')
plt.title('% Agree per Participant')
plt.xlabel('% Agree')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Distribution of % disagree per Participant
plt.figure(figsize=(10, 6))
plt.hist(data['% disagree'], bins=20, color='red', edgecolor='black')
plt.title('% Disagree per Participant')
plt.xlabel('% Disagree')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Distribution of % pass per Participant
plt.figure(figsize=(10, 6))
plt.hist(data['% pass'], bins=20, color='orange', edgecolor='black')
plt.title('% Pass per Participant')
plt.xlabel('% Pass')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Stacked Distribution showing % agree, % disagree, and % pass per Participant
# stacked on top of each other
plt.figure(figsize=(10, 6))
plt.hist([data['% agree'], data['% disagree'], data['% pass']], bins=20, stacked=True, color=['green', 'red', 'orange'], edgecolor='black')
plt.title('% Agree, % Disagree, and % Pass per Participant')
plt.xlabel('Percentage')
plt.ylabel('Frequency')
plt.legend(['% Agree', '% Disagree', '% Pass'])
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()


# Distribution of # of comments submitted per Participant
plt.figure(figsize=(10, 6))
plt.hist(data['n-comments'], bins=20, color='purple', edgecolor='black')
plt.title('# of Comments Submitted per Participant')
plt.xlabel('Number of Comments')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Step 5: Calculate per Comment statistics
# Extract only the comment columns (assumed to be all numeric after standard columns)
comment_columns = data.columns[8:]  # Adjust the index if the comment columns start at a different position

# Initialize lists to store the results
agree_percentages = []
disagree_percentages = []
pass_percentages = []
vote_counts = []

# Loop through each comment column to calculate statistics
for col in comment_columns:
    votes = data[col].dropna()  # Drop NaN values to get only the votes
    total_votes = len(votes)
    agree_percentage = (votes == 1).sum() / total_votes if total_votes > 0 else 0
    disagree_percentage = (votes == -1).sum() / total_votes if total_votes > 0 else 0
    pass_percentage = (votes == 0).sum() / total_votes if total_votes > 0 else 0

    # Append results to lists
    vote_counts.append(total_votes)
    agree_percentages.append(agree_percentage)
    disagree_percentages.append(disagree_percentage)
    pass_percentages.append(pass_percentage)

# Plot the distributions of comment-related metrics
plt.figure(figsize=(10, 6))
plt.hist(agree_percentages, bins=20, color='green', edgecolor='black')
plt.title('% Agree per Comment')
plt.xlabel('% Agree')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

plt.figure(figsize=(10, 6))
plt.hist(disagree_percentages, bins=20, color='red', edgecolor='black')
plt.title('% Disagree per Comment')
plt.xlabel('% Disagree')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

plt.figure(figsize=(10, 6))
plt.hist(pass_percentages, bins=20, color='orange', edgecolor='black')
plt.title('% Pass per Comment')
plt.xlabel('% Pass')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

plt.figure(figsize=(10, 6))
plt.hist(vote_counts, bins=20, color='blue', edgecolor='black')
plt.title('# Votes per Comment')
plt.xlabel('# Votes')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()



"""# Simulate Similar Participants and Comments"""

import numpy as np
import matplotlib.pyplot as plt
import random
import pandas as pd
from scipy.stats import beta


# Sample data that reflects the actual distribution of voting probabilities (you should adjust these values based on your actual data)
# Replace these example values with the actual distributions if possible.
actual_agree_probs = np.random.beta(2, 5, 1000)  # Example distribution of % agree
actual_disagree_probs = np.random.beta(2, 8, 1000)  # Example distribution of % disagree
actual_pass_probs = 1 - (actual_agree_probs + actual_disagree_probs)  # % pass calculated from the rest


# Step 0: Clean the data to fit within (0, 1) range required by Beta distribution
# Slightly adjust any exact 0s or 1s to be within (0, 1)
actual_agree = data['% agree'].clip(lower=0.001, upper=0.999)  # Adjust % agree values
actual_disagree = data['% disagree'].clip(lower=0.001, upper=0.999)  # Adjust % disagree values


# Step 0: Fit Beta distribution to the actual data
agree_a, agree_b, _, _ = beta.fit(actual_agree, floc=0, fscale=1)  # Fit % agree
disagree_a, disagree_b, _, _ = beta.fit(actual_disagree, floc=0, fscale=1)  # Fit % disagree


# Step 0: Extract the actual vote counts from your data
# Assuming your DataFrame has a column 'n-votes' representing the number of votes cast by each participant
actual_vote_counts = data['n-votes']

# Step 1: Fit the Negative Binomial distribution to the actual vote counts
# Estimate parameters (n, p) using the fit method
mean_votes = actual_vote_counts.mean()
var_votes = actual_vote_counts.var()

# Calculate parameters for Negative Binomial from mean and variance
# n (dispersion) = (mean^2) / (variance - mean), p = mean / (mean + n)
actual_n = (mean_votes ** 2) / (var_votes - mean_votes) if var_votes > mean_votes else 10
actual_p = mean_votes / (mean_votes + actual_n)

# Step 1: Simulate participant vote probabilities
def simulate_participant_vote_probability():
    """
    Simulates the % breakdown of vote types (agree, disagree, pass) for a participant
    based on actual data distributions.

    Returns:
    - A tuple [% agree, % disagree, % pass] representing a single participant's voting probabilities.
    """
   # Sample from the fitted Beta distributions
    agree = np.random.beta(agree_a, agree_b)
    disagree = np.random.beta(disagree_a, disagree_b)
    pass_prob = max(0, 1 - (agree + disagree))  # Ensure probabilities sum to 1

    # Normalize to avoid negative or overflow probabilities
    total = agree + disagree + pass_prob
    agree /= total
    disagree /= total
    pass_prob /= total

    return [agree, disagree, pass_prob]

# Step 2: Simulate number of votes cast by each participant
def simulate_votes_cast(n=actual_n, p=actual_p):
    """
    Simulates the number of votes cast by a participant using a Negative Binomial distribution.

    Parameters:
    - mean_votes: The average number of votes participants cast.
    - dispersion: Dispersion factor controlling variance; higher values allow more spread.

    Returns:
    - An integer representing the number of votes cast by a simulated participant.
    """
     # Generate a sample count using the fitted Negative Binomial parameters
    votes_cast = np.random.negative_binomial(n, p)
    return max(votes_cast, 1)  # Ensure at least one vote is cast


# Step 3: Simulate the voting process for a given number of participants
def simulate_votes(num_participants):
    """
    Simulates voting behavior for the specified number of participants.

    Parameters:
    - num_participants: The number of participants to simulate.

    Returns:
    - A list of lists of simulated votes where each list is a set of votes from a partifipant, represented by 1 (Agree), -1 (Disagree), or 0 (Pass).
    """
    simulated_votes = []

    for _ in range(num_participants):
        # Simulate the number of votes this participant will cast
        votes_to_cast = simulate_votes_cast()

        # Simulate the participant's vote probability distribution
        agree_prob, disagree_prob, pass_prob = simulate_participant_vote_probability()

        # Cast votes according to the probabilities
        votes = np.random.choice(
            [1, -1, 0],  # 1 = Agree, -1 = Disagree, 0 = Pass
            size=votes_to_cast,
            p=[agree_prob, disagree_prob, pass_prob]
        )

        # Add this participant's votes to the overall list
        simulated_votes.append(votes)

    return simulated_votes

# Example usage: Simulate votes for 100 participants
num_participants = 1000
simulated_votes = simulate_votes(num_participants)

# flatten simulated votes into a single list of all votes
all_simulated_votes = [vote for participant_votes in simulated_votes for vote in participant_votes]

# Get the counts of votes submitted by each Participant
vote_counts = [len(participant_votes) for participant_votes in simulated_votes]

# Plot the distribution of # of votes per simulated Participant
plt.figure(figsize=(12, 6))
plt.hist(vote_counts, bins=np.arange(min(vote_counts), max(vote_counts) + 5, 5),
         color='skyblue', edgecolor='black')
plt.title('Adjusted Simulated Distribution of Votes Cast per Participant')
plt.xlabel('Number of Votes')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.xlim(0, 200)  # Adjust x-axis to match observed data range
plt.show()

# Plot the distribution of simulated vote outcomes
plt.figure(figsize=(10, 6))
plt.hist(all_simulated_votes, bins=3, color='skyblue', edgecolor='black', align='mid', rwidth=0.6)
plt.xticks([-1, 0, 1], ['Disagree', 'Pass', 'Agree'])
plt.title('Simulated Vote Outcomes for Participants')
plt.xlabel('Vote Type')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Calculate n-agree, n-disagree, n-pass, and n-votes per simulated Participant from simulated data
simulated_data = pd.DataFrame(
    {
        'n-agree': [np.sum(vote == 1) for vote in simulated_votes],
        'n-disagree': [np.sum(vote == -1) for vote in simulated_votes],
        'n-pass': [np.sum(vote == 0) for vote in simulated_votes],
        'n-votes': [len(vote) for vote in simulated_votes]
    }
)

# Calculate % agree, % disagree, and % pass per participant
simulated_data['% agree'] = simulated_data['n-agree'] / simulated_data['n-votes']
simulated_data['% disagree'] = simulated_data['n-disagree'] / simulated_data['n-votes']
simulated_data['% pass'] = simulated_data['n-pass'] / simulated_data['n-votes']


# Stacked Distribution showing % agree, % disagree, and % pass per Participant
# stacked on top of each other
plt.figure(figsize=(10, 6))
plt.hist([simulated_data['% agree'], simulated_data['% disagree'], simulated_data['% pass']], bins=20, stacked=True, color=['green', 'red', 'orange'], edgecolor='black')
plt.title('% Agree, % Disagree, and % Pass per Participant')
plt.xlabel('Percentage')
plt.ylabel('Frequency')
plt.legend(['% Agree', '% Disagree', '% Pass'])
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Streamlined code that prompts user to upload Polis data then defines functions to simulate votes and comments by participants, specifically these functions:
# - calculate_statements_per_participant
# - calculate_votes_per_participant
# - calculate_vote_distribution_per_participant

# TODO: Fill in

